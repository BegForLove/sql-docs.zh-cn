---
title: 事务隔离级别 | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.suite: sql
ms.technology: connectivity
ms.tgt_pltfrm: ''
ms.topic: conceptual
helpviewer_keywords:
- dirty reads [ODBC]
- isolation levels [ODBC]
- nonrepeatable reads [ODBC]
- read uncommitted [ODBC]
- read committed [ODBC]
- serializable reads [ODBC]
- phantoms [ODBC]
- transaction isolation [ODBC]
- repeatable reads [ODBC]
- transactions [ODBC], isolation
ms.assetid: 0d638d55-ffd0-48fb-834b-406f466214d4
caps.latest.revision: 6
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 2dc2b07938b8100128eaf8433aa4ab48002c357d
ms.sourcegitcommit: 1740f3090b168c0e809611a7aa6fd514075616bf
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/03/2018
---
# <a name="transaction-isolation-levels"></a>事务隔离级别
*事务隔离级别*是事务隔离成功的范围内的度量。 具体而言，事务隔离级别是根据存在以下现象相符合定义的：  
  
-   **脏读**A*脏读*事务读取尚未提交的数据时发生。 例如，假设事务 1 更新行。 事务 2 在事务 1 提交更新之前读取更新的行。 如果事务 1 回滚更改，则事务 2 将具有读取永远不会视为已存在的数据。  
  
-   **不可重复读取**A*不可重复读取*两次读取同一行但获取每个时间的不同的数据的事务时发生。 例如，假设事务 1 读取行。 事务 2 更新或删除该行并提交 update 或 delete。 如果事务 1 重新读取行，则它将检索不同的行值或发现该行已被删除。  
  
-   **幻像**A*幻像*是一个行匹配搜索条件，但最初未检测到。 例如，假设事务 1 中读取一套满足某些搜索条件的行。 事务 2 生成一个新行 （通过更新或插入） 事务 1 搜索条件相匹配。 如果事务 1 reexecutes 读取行的语句，它将获取一组不同的行。  
  
 四个事务隔离级别 （如所定义的 SQL 92） 会按这些现象相符合定义。 在下表中，"X"标记可以发生的每个出现这种现象。  
  
|事务隔离级别|脏读|不可重复读取|幻像|  
|---------------------------------|-----------------|-------------------------|--------------|  
|未提交读|X|X|X|  
|已提交读|--|X|X|  
|可重复读|--|--|X|  
|可序列化|--|--|--|  
  
 下表介绍 DBMS 可能实现的事务隔离级别的简单方式。  
  
> [!IMPORTANT]  
>  大多数 Dbms 使用比这些更为复杂的模式来提高并发性。 仅供说明之提供了这些示例。 具体而言，ODBC 并未规定如何特定 Dbms 隔离相互的事务。  
  
|事务隔离|可能的实现|  
|---------------------------|-----------------------------|  
|未提交读|事务不是相互隔离的。 如果 DBMS 支持其他事务隔离级别，它将忽略任何它使用来实现这两种级别的机制。 以便他们不产生不利影响其他事务，在 Read Uncommitted 级别运行的事务将是通常是只读的。|  
|已提交读|在事务等待，直到由其他事务写入锁定的行不会被锁定;这可以防止读取任何"脏"的数据。<br /><br /> 事务保留 （如果它仅将读取行） 的读取或写入锁定 （如果它更新或删除的行） 的当前行以防止其他事务更新或删除它。 当它移出当前行时，事务将释放读取的锁。 它包含写入锁，直到提交或回滚它。|  
|可重复读|在事务等待，直到由其他事务写入锁定的行不会被锁定;这可以防止读取任何"脏"的数据。<br /><br /> 事务持有读取的锁对它返回到应用程序和写入锁它插入、 更新或删除的所有行的所有行。 例如，如果事务包含的 SQL 语句**选择\*从订单**，事务读取锁定的行按应用程序读取它们。 如果事务包含的 SQL 语句**删除从订单其中状态 = 关闭**，如将其删除的行数事务写入锁。<br /><br /> 由于其他事务不能更新或删除这些行，当前事务可避免任何不可重复读取。 提交或回滚时，事务将释放其锁定。|  
|可序列化|在事务等待，直到由其他事务写入锁定的行不会被锁定;这可以防止读取任何"脏"的数据。<br /><br /> 事务持有读取的锁 （如果它仅读取行） 或上的范围的写入锁 （如果它能够更新或删除行） 行它影响。 例如，如果事务包含的 SQL 语句**选择\*从订单**，范围是整个 Orders 表; 事务读取锁定表而不会不允许任何新行插入到它。 如果事务包含的 SQL 语句**删除从订单其中状态 = 关闭**，范围为"已关闭"状态的所有行; 事务写入锁订单中的所有行具有都表的"已关闭"而不会状态不允许要插入或更新以便得到的行的状态为"已关闭"的任何行。<br /><br /> 由于其他事务不能更新或删除范围中的行，当前事务可避免任何不可重复读取。 由于其他事务不能在范围中插入任何行，当前事务可避免任何幻像。 提交或回滚时，事务将释放其锁定。|  
  
 务必要注意的事务隔离级别不会影响事务的功能，以查看其自己的更改;事务可以始终查看他们所做的任何更改。 例如，事务可能包含两个**更新**语句，其中第一个引发的所有雇员的工资 10%的和第二个设置的任何员工支付超出该数量到某些最大时间。 此操作成功作为单个事务，所以第二个**更新**语句可以看到的第一个结果。
