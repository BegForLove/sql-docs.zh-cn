---
title: 事务隔离级别 | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- dirty reads [ODBC]
- isolation levels [ODBC]
- nonrepeatable reads [ODBC]
- read uncommitted [ODBC]
- read committed [ODBC]
- serializable reads [ODBC]
- phantoms [ODBC]
- transaction isolation [ODBC]
- repeatable reads [ODBC]
- transactions [ODBC], isolation
ms.assetid: 0d638d55-ffd0-48fb-834b-406f466214d4
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 83197b1b487db6c52a8fe9b7a57dd6af55c33571
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/15/2019
ms.locfileid: "67985104"
---
# <a name="transaction-isolation-levels"></a>事务隔离级别
*事务隔离级别*隔离成功事务的范围内的一种度量值。 具体而言，事务隔离级别定义由存在以下现象：  
  
-   **脏读**A*脏读*事务读取尚未提交的数据时发生。 例如，假设事务 1 更新行。 事务 2 在事务 1 提交更新之前读取更新的行。 如果事务 1 回滚更改，将具有事务 2 读取永远不会视为已存在于数据。  
  
-   **不可重复读取**A*不可重复读*事务两次读取同一行，但每次获取不同的数据时发生。 例如，假设事务 1 读取某行。 事务 2 更新或删除该行并提交 update 或 delete。 如果事务 1 重新读取行，它将检索不同的行值或发现该行已被删除。  
  
-   **幻影**A*幻像*是与搜索条件匹配，但是最初未检测到的行。 例如，假设事务 1 读取一组满足某些搜索条件的行。 事务 2 生成一个新行 （通过更新或插入） 事务 1 搜索条件相匹配。 如果事务 1 reexecutes 读取这些行的语句，它获取一组不同的行。  
  
 根据这些现象定义四个事务隔离级别 （如 SQL-92 所定义）。 下表中"X"将标记每个可能发生的现象。  
  
|事务隔离级别|脏读|不可重复读取|幻影|  
|---------------------------------|-----------------|-------------------------|--------------|  
|未提交读|X|X|X|  
|已提交读|--|X|X|  
|可重复读|--|--|X|  
|可序列化|--|--|--|  
  
 下表介绍 DBMS 可能会实现事务隔离级别的简单方法。  
  
> [!IMPORTANT]  
>  大多数 Dbms 使用比这些更为复杂的模式来提高并发性。 仅供说明之提供了这些示例。 特别是，ODBC 不规定如何特定 Dbms 隔离每个事务。  
  
|事务隔离|可能的实现|  
|---------------------------|-----------------------------|  
|未提交读|事务不是相互隔离的。 如果 DBMS 支持其他事务隔离级别，它会忽略它使用来实现这两种级别的任何机制。 以便它们不产生不利影响其他事务，在 Read Uncommitted 级别运行的事务是通常是只读的。|  
|已提交读|在事务等待，直到由其他事务写入锁定的行不会被锁定;这可以防止它读取任何"更新"的数据。<br /><br /> 事务持有读取的锁 （如果它仅读取行） 或写入锁定 （如果它更新或删除的行） 的当前行，以防止其他事务更新或删除它。 事务释放读的锁时即会关闭当前行。 它保留写锁，直到提交或回滚。|  
|可重复读|在事务等待，直到由其他事务写入锁定的行不会被锁定;这可以防止它读取任何"更新"的数据。<br /><br /> 事务持有读取的锁，它返回到的应用程序和写锁，它插入、 更新或删除的所有行的所有行。 例如，如果事务包含的 SQL 语句**选择\*从订单**，如应用程序读取它们的事务读取锁定行。 如果在事务中包含的 SQL 语句**删除从订单的状态 = 已关闭**，如将其删除的行事务写入锁。<br /><br /> 由于其他事务不能更新或删除这些行，当前事务可以避免任何不可重复读取。 事务提交或回滚时释放其锁。|  
|可序列化|在事务等待，直到由其他事务写入锁定的行不会被锁定;这可以防止它读取任何"更新"的数据。<br /><br /> 事务持有读取的锁 （如果它仅读取的行） 或写入锁 （如果它可以更新或删除行） 的范围上它的行影响。 例如，如果事务包含的 SQL 语句**选择\*从订单**，范围是整个 Orders 表; 事务读取锁定表而不会允许任何新行插入到它。 如果在事务中包含的 SQL 语句**删除从订单的状态 = 已关闭**，范围为"已关闭"状态的所有行; 事务写入锁订单中的所有行具有都表状态为"CLOSED"而不会不允许任何行要插入或更新，以便得到的行的状态为"已关闭"。<br /><br /> 由于其他事务不能更新或删除范围中的行，当前事务可以避免任何不可重复读取。 由于其他事务不能在范围中插入任何行，当前事务可以避免任何幻影。 事务提交或回滚时释放其锁定。|  
  
 务必要注意的事务隔离级别不会影响事务的功能，以查看其自己的更改;事务始终可以查看他们所做的任何更改。 例如，事务可能包含两个**更新**语句，其中第一个引发的所有员工的薪水 10%和第二个设置的任何员工的薪水，超过该数量为某些最大数量。 此操作成功作为单个事务只是因为第二个**更新**语句可以看到的第一个结果。
