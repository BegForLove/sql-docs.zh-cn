---
title: 事务隔离级别 （ODBC） |微软文档
ms.custom: seo-dt-2019
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- dirty reads [ODBC]
- isolation levels [ODBC]
- nonrepeatable reads [ODBC]
- read uncommitted [ODBC]
- read committed [ODBC]
- serializable reads [ODBC]
- phantoms [ODBC]
- transaction isolation [ODBC]
- repeatable reads [ODBC]
- transactions [ODBC], isolation
ms.assetid: 0d638d55-ffd0-48fb-834b-406f466214d4
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 622b4cd7f0db259b5ecfd5be63b27df64be965e7
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/14/2020
ms.locfileid: "81298030"
---
# <a name="transaction-isolation-levels-odbc"></a>事务隔离级别 （ODBC）
*事务隔离级别*是事务隔离成功程度的度量。 特别是，事务隔离级别由是否存在以下现象定义：  
  
-   **脏读**当事务读取尚未提交的数据时，将发生*脏读*。 例如，假设事务 1 更新一行。 事务 2 在事务 1 提交更新之前读取更新的行。 如果事务 1 回滚更改，事务 2 将具有被视为从未存在的数据。  
  
-   **不可重复读取**当事务读取同一行两次，但每次都获取不同的数据时，将发生*不可重复的读取*。 例如，假设事务 1 读取一行。 事务 2 更新或删除该行并提交更新或删除。 如果事务 1 重读该行，它将检索不同的行值或发现该行已被删除。  
  
-   **幻影***幻像*是符合搜索条件但最初看不到的行。 例如，假设事务 1 读取一组满足某些搜索条件的行。 事务 2 生成与事务 1 的搜索条件匹配的新行（通过更新或插入）。 如果事务 1 重新执行读取行的语句，它将获得一组不同的行。  
  
 四个事务隔离级别（由 SQL-92 定义）是根据这些现象定义的。 在下表中，"X"标记可能发生的每个现象。  
  
|事务隔离级别|脏读|不可重复读取|幽灵|  
|---------------------------------|-----------------|-------------------------|--------------|  
|未提交读|X|X|X|  
|已提交读|--|X|X|  
|可重复读|--|--|X|  
|可序列化|--|--|--|  
  
 下表描述了 DBMS 实现事务隔离级别的简单方法。  
  
> [!IMPORTANT]  
>  大多数 DBMS 使用比这些更复杂的方案来增加并发性。 这些示例仅用于说明目的。 特别是，ODBC 没有规定特定的 DBMS 如何将事务彼此隔离。  
  
|事务隔离|可能实现|  
|---------------------------|-----------------------------|  
|未提交读|事务不会彼此隔离。 如果 DBMS 支持其他事务隔离级别，它将忽略它用于实现这些级别的任何机制。 因此，它们不会对其他事务产生负面影响，在读取未提交级别运行的事务通常是只读的。|  
|已提交读|事务等待其他事务写入锁定的行解锁;这样可以防止它读取任何"脏"数据。<br /><br /> 事务在当前行上持有读取锁（如果只读取行）或写入锁（如果更新或删除该行），以防止其他事务更新或删除该行。 事务释放读取锁时，它移动离开当前行。 它保留写入锁，直到它被提交或回滚。|  
|可重复读|事务等待其他事务写入锁定的行解锁;这样可以防止它读取任何"脏"数据。<br /><br /> 事务保留返回到应用程序的所有行的读取锁，并在它插入、更新或删除的所有行上写入锁。 例如，如果事务包含 SQL 语句 **"从\*订单中选择**"，则事务在应用程序获取行时读取锁定行。 如果事务包含 SQL 语句 **"从订单中删除"状态 = "关闭"，** 则事务在删除行时将写入行。<br /><br /> 由于其他事务无法更新或删除这些行，因此当前事务会避免任何不可重复的读取。 事务在提交或回滚时释放其锁。|  
|可序列化|事务等待其他事务写入锁定的行解锁;这样可以防止它读取任何"脏"数据。<br /><br /> 事务在它所影响的行范围内持有读取锁（如果只读取行）或写入锁（如果它可以更新或删除行）。 例如，如果事务包含 SQL 语句"从订单中选择"，则范围是整个订单表;如果事务包含 SQL 语句 **"从订单中选择\*"，** 则范围为整个订单表。事务读取锁定表，不允许将任何新行插入其中。 如果事务包括 SQL 语句 **"从订单中删除"状态 = "关闭"，** 则范围是所有状态为"关闭"的行;事务写入锁定状态为"关闭"的"订单"表中的所有行，并且不允许插入或更新任何行，以便生成的行的状态为"关闭"。<br /><br /> 由于其他事务无法更新或删除范围内的行，因此当前事务会避免任何不可重复的读取。 由于其他事务无法在范围内插入任何行，因此当前事务可避免任何幻象。 事务在提交或回滚时释放其锁。|  
  
 请务必注意，事务隔离级别不会影响事务查看自身更改的能力;因此，事务隔离级别不会影响事务本身的更改。事务始终可以看到它们所做的任何更改。 例如，事务可能由两个**UPDATE**语句组成，第一个语句将所有员工的工资提高 10%，第二个语句将任何员工的工资设定为该金额的某个最高金额。 这仅作为单个事务成功，因为第二个 UPDATE 语句可以看到第一个**事务**的结果。
